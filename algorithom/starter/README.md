# 算法入门前须知

> 算法（Algorithm）是指解题方案的准确而完整的描述，是一系列解决问题的清晰指令，算法代表着用系统的方法描述解决问题的策略机制。也就是说，能够对一定规范的输入，在有限时间内获得所要求的输出。如果一个算法有缺陷，或不适合于某个问题，执行这个算法将不会解决这个问题。不同的算法可能用不同的时间、空间或效率来完成同样的任务。一个算法的优劣可以用空间复杂度与时间复杂度来衡量。  
> 算法中的指令描述的是一个计算，当其运行时能从一个初始状态和（可能为空的）初始输入开始，经过一系列有限而清晰定义的状态，最终产生输出并停止于一个终态。一个状态到另一个状态的转移不一定是确定的。随机化算法在内的一些算法，包含了一些随机输入。  
> ————来自wiki

![](img/run.jpg)

## 学习之前应该知道什么

众所周知，计算机学脱胎于数学。目前计算机学的分支越发庞大，很多分支已经与数学没有太大关系了，但是算法仍然是与数学息息相关的那一分支，说算法是数学的一部分也不为过。  
在计算机领域，算法与语言无关，著名的《算法导论》一书使用其自己定义的一种伪代码来讲解算法（伪代码书写类似于计算机语言但并不是一种真实可用的计算机语言，使用它只是为了便于使用各种语言的人理解算法的**代码逻辑**）。算法只是一种抽象的思想，没有明确的不可变的代码实现，但因为计算机语言的简洁性，一个算法的同一语言的代码实现往往差别也不会特别大。  
一个程序员可以一辈子不接触算法，因为很多常用算法已经由库文件实现。算法最重要的作用是**大大提高运算效率**（这种提高往往类似于数学的公式简化)，但在很多情景下，常用算法已经可以做到人类察觉不到或可以接受的速度，这时程序员也尽可以不使用算法优化代码。但显然，在很多重要领域（比如高性能计算），一个好的算法带来的差别是不可想象的。  
我们往往把数据结构和算法分开来讲，但我觉得数据结构是算法的子集，它不是代码逻辑，它是一种数据组织逻辑。  
@MuZhou 以自己的亲身感受来说，**每个程序员都最好或多或少的接触算法**，因为学习算法会让人对代码逻辑有新的理解，在日后的代码工程中，这种影响是潜移默化的，你的代码会自然而然地变得更加优秀。但是，**如果一个人想做顶级算法工程师不仅需要汗水，还需要天分**。我的这种论断是没有足够的依据的，但我只想说，算法是数学的，顶级的数学家是有足够的汗水就做得了的吗？  

## 当我们谈论算法时，我们还会谈论什么

说到算法，不得不提的就是**复杂度**和**评测姬**。如果你没有了解过算法却看过[类似于解题报告的文章](https://muzhou.tech/blog/2017/11/08/solution/)，你一定会被文中的各种符号和长篇大论的逻辑分析吓到，而那些你没有见过的符号里，很大部分就是和复杂度、评测姬有关的。  

### 代码复杂度不是代码复杂度

代码复杂度不是代码复杂度，代码复杂度有两个维度：时间复杂度和空间复杂度。  
对于一个算法，它的内存占用和执行速度是评价它好坏的重要标准，而复杂度就是我们用于估算它的内存占用和运行时间的单位。下面我们直接举例说明：  

```c
//本例代码没有任何实际意义，仅仅为了使代码量最少
int n = 1000;
int array[n];
for(int i = 0; i < n; i = i + 1)
    for(int j = 0; j < n * 2; j = j + 1)
        array[i] = i + j;
for(int i = 0; i < n; i = i + 1)
    array[i] = 0;
```

上面的代码总共申请了大约 n 个 int 变量，执行了 n * n * 2 + n 次循环。于是我们将这段代码的空间复杂度标记为 O(n)，空间复杂度标记为 O(n*n+n)。现在我们将 n 修改为一个由用户输入的数，那么代码的复杂度仍然没有变化。同样，无论是在八位机还是六十四位机上执行这段代码，它的复杂度都不会改变，这就是复杂度的意义。  
在上面估算复杂度的时候，我们只关注了数组的内存占用和循环的次数，这是在估算复杂度的时候经常会做的，一般情况下，我们在估算复杂度的时候，只关注**数量级**（100 和 1000 差一个数量级，200 和 3000 同样也是差一个数量级，使用科学计数法计数时的指数就是数量级），事实上在上面的例子中空间复杂度一般表示为 O(n^2) 即只保留多项式中指数最大的一项且不保留常数。

### 评测姬不是人

评测姬不是人，各种意义上的那种。  
一个编译型语言❨比如 c java❩可以使用编译器查错，一个解释型语言❨比如 javascript❩也可以使用解释器查错，在机器查错无误后还需要人工测试代码有无问题。这里就涉及到代码的两种错误：语法错误和逻辑错误。语法错误就是代码不符合语言的语法规则，逻辑错误就是代码能正常执行但不能得到预期的运行结果。在我们编写算法时，我们遇到的主要问题不仅仅是这两种，还有代码效率达不到预期，特殊情况处理❨容错❩等等，有着这种问题的代码仍然可以在特定的条件下正常运行，但作为算法它是不合格的。为了自动化评价一个算法的代码实现是否合格，评测姬诞生了。  
最好的学习方法之一就是做题，算法也是如此。一道算法题往往包含了对程序功能的描述，输入数据和答案的格式，答题者写出的代码交给评测姬编译执行，与一份出题者提供的正确的代码❨标准程序，标程❩对比在同样的输入数据下能否输出相同的答案。下面是一道经典的A+B问题及评测姬常见评测结果：

#### A+B问题

|时间限制|空间限制|代码限制|语言|
|---|---|---|---|
|1000ms❨大部分题目的限制时间❩|1024MB❨算法题目往往需要使用大量内存来测试大数据量的执行效率，本题是个例外❩|10KB❨防止暴力地将所有可能答案放进源代码❩|c/c++|

**题目描述**

输入两个整数，中间用一个空格隔开，输出两个整数相加的结果

**输入输出描述**

输入两个整数 a b，中间用一个空格隔开❨0 <= a ,b <= 1000000000❩  
输出一个整数，为两数相加的结果  

输入输出都使用标准输入输出❨即直接使用printf scanf cin cout❩

**输入输出样例**

`1.in`  
```
1 1
```

`1.out`  
```
2
```

|代表性评测错误|简称|解释|
|---|---|---|
|Compile Error|CE|编译错误，奇耻大辱|
|Time Limit Exceeded|TLE 或 T|程序运行时间超过题目运行时间限制|
|Memory Limit Exceeded|MLE|程序申请的内存超出题目限制|
|Runtime Error|RE|运行时错误，即传说中的程序崩溃，迷惑错误之一|
|Wrong Answer|WA|答案错误|
|Accepted|AC|通过评测|

