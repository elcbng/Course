# 算法入门前须知

> 算法（Algorithm）是指解题方案的准确而完整的描述，是一系列解决问题的清晰指令，算法代表着用系统的方法描述解决问题的策略机制。也就是说，能够对一定规范的输入，在有限时间内获得所要求的输出。如果一个算法有缺陷，或不适合于某个问题，执行这个算法将不会解决这个问题。不同的算法可能用不同的时间、空间或效率来完成同样的任务。一个算法的优劣可以用空间复杂度与时间复杂度来衡量。  
> 算法中的指令描述的是一个计算，当其运行时能从一个初始状态和（可能为空的）初始输入开始，经过一系列有限而清晰定义的状态，最终产生输出并停止于一个终态。一个状态到另一个状态的转移不一定是确定的。随机化算法在内的一些算法，包含了一些随机输入。  
> ————来自wiki

![](img/run.jpg)

## 学习之前应该知道什么

众所周知，计算机学脱胎于数学。目前计算机学的分支越发庞大，很多分支已经与数学没有太大关系了，但是算法仍然是与数学息息相关的那一分支，说算法是数学的一部分也不为过。  
在计算机领域，算法与语言无关，著名的《算法导论》一书使用其自己定义的一种伪代码来讲解算法（伪代码书写类似于计算机语言但并不是一种真实可用的计算机语言，使用它只是为了便于使用各种语言的人理解算法的**代码逻辑**）。算法只是一种抽象的思想，没有明确的不可变的代码实现，但因为计算机语言的简洁性，一个算法的同一语言的代码实现往往差别也不会特别大。  
一个程序员可以一辈子不接触算法，因为很多常用算法已经由库文件实现。算法最重要的作用是**大大提高运算效率**（这种提高往往类似于数学的公式简化)，但在很多情景下，常用算法已经可以做到人类察觉不到或可以接受的速度，这时程序员也尽可以不使用算法优化代码。但显然，在很多重要领域（比如高性能计算），一个好的算法带来的差别是不可想象的。  
我们往往把数据结构和算法分开来讲，但我觉得数据结构是算法的子集，它不是代码逻辑，它是一种数据组织逻辑。  
@MuZhou 以自己的亲身感受来说，**每个程序员都最好或多或少的接触算法**，因为学习算法会让人对代码逻辑有新的理解，在日后的代码工程中，这种影响是潜移默化的，你的代码会自然而然地变得更加优秀。但是，**如果一个人想做顶级算法工程师不仅需要汗水，还需要天分**。我的这种论断是没有足够的依据的，但我只想说，算法是数学的，顶级的数学家是有足够的汗水就做得了的吗？  

## 当我们谈论算法时，我们还会谈论什么

说到算法，不得不提的就是**复杂度**和**评测姬**。如果你没有了解过算法却看过[类似于解题报告的文章](https://muzhou.tech/blog/2017/11/08/solution/)，你一定会被文中的各种符号和长篇大论的逻辑分析吓到，而那些你没有见过的符号里，很大部分就是和复杂度、评测姬有关的。  

### 代码复杂度不是代码复杂度

代码复杂度不是代码复杂度，代码复杂度有两个维度：时间复杂度和空间复杂度。  
我们日常所讨论的复杂度只是一个大概的数据，一般用 O(n) O(n^2) 这样的符号表示，括号里的 n 表示数据量的大小。时间复杂度和空间复杂度的符号一样，只是用来比较不同算法在数量级上的效率差异。但并不仅仅是这样，代码复杂度有更加严谨复杂的表示方法（复杂度上界下界之类），此处暂不讨论。  

### 评测姬不是人

评测姬不是人，各种意义上的那种。  
一个编译型语言可以使用编译器查错，一个解释型语言也可以使用解释器查错，在机器查错无误后还需要人工测试代码问题。这里就涉及到代码的两种错误：语法错误和逻辑错误。在我们编写算法时，我们遇到的主要问题不仅仅是这两种，逻辑漏洞、代码复杂度达不到预期，有着这种问题的代码仍然可以在特定的条件下正常运行，但作为算法它是不合格的，于是评测姬诞生了。  
简单来说评测姬会自动编译执行代码并通过预置的文件对代码的各个方面进行检查从而得出评测结果（算法领域一般都是以题目的形式出现的，往往有出题者设置的多组输入数据和对应的正确答案），而这些结果渐渐有了简称：

|代表性评测错误|简称|解释|
|---|---|---|
|Compile Error|CE|奇耻大辱|
|Time Limit Exceeded|TLE 或 T|程序运行时间超过题目运行时间限制|
|Memory Limit Exceeded|MLE|程序申请的内存超出题目限制|
|Runtime Error|RE|运行时错误，即传说中的程序崩溃，迷惑错误之一|
|Wrong Answer|WA|答案错误|
|Accepted|AC|通过评测|

